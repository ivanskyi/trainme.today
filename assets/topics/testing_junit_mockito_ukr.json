{
  "topic": {
    "id": "testing_junit_mockito_ukr",
    "name": "Тестування в Java (JUnit, Mockito)",
    "description": "20 технічних запитань з JUnit і Mockito для розробників",
    "tests": [
      {
        "test_id": "unit_test_java",
        "test_title": "JUnit та Mockito: технічний тест",
        "questions": [
          {
            "question_id": "q1",
            "question_text": "Яка анотація в JUnit 5 використовується для позначення тестового методу?",
            "options": [
              { "option_id": "a", "text": "@Test" },
              { "option_id": "b", "text": "@RunWith" },
              { "option_id": "c", "text": "@Before" },
              { "option_id": "d", "text": "@Check" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q2",
            "question_text": "Що робить метод `verify()` в Mockito?",
            "options": [
              { "option_id": "a", "text": "Перевіряє, що метод був викликаний з очікуваними аргументами" },
              { "option_id": "b", "text": "Створює мок" },
              { "option_id": "c", "text": "Ініціалізує поля перед тестом" },
              { "option_id": "d", "text": "Встановлює значення повернення мока" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q3",
            "question_text": "Як задати значення, яке повинен повертати мок-об’єкт у Mockito?",
            "options": [
              { "option_id": "a", "text": "when(mock.method()).thenReturn(value)" },
              { "option_id": "b", "text": "mock.setReturn(value)" },
              { "option_id": "c", "text": "stub(mock).returning(value)" },
              { "option_id": "d", "text": "given(value).willReturn(mock)" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q4",
            "question_text": "Яка анотація в JUnit 5 використовується для методу, який виконується перед кожним тестом?",
            "options": [
              { "option_id": "a", "text": "@BeforeEach" },
              { "option_id": "b", "text": "@BeforeAll" },
              { "option_id": "c", "text": "@Setup" },
              { "option_id": "d", "text": "@Before" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q5",
            "question_text": "Що означає `@ExtendWith(MockitoExtension.class)` у JUnit 5?",
            "options": [
              { "option_id": "a", "text": "Додає підтримку Mockito в JUnit 5 тестах" },
              { "option_id": "b", "text": "Реєструє новий кастомний Runner" },
              { "option_id": "c", "text": "Запускає тести асинхронно" },
              { "option_id": "d", "text": "Підключає Spring Boot контекст" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q6",
            "question_text": "Як створити мок-об’єкт у Mockito без анотацій?",
            "options": [
              { "option_id": "a", "text": "MyClass mock = Mockito.mock(MyClass.class);" },
              { "option_id": "b", "text": "MyClass mock = new MyClass();" },
              { "option_id": "c", "text": "MyClass mock = Mock.create(MyClass.class);" },
              { "option_id": "d", "text": "MyClass mock = Mockup(MyClass.class);" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q7",
            "question_text": "Яку помилку згенерує Mockito, якщо метод не викликано, але `verify` очікує його виклик?",
            "options": [
              { "option_id": "a", "text": "WantedButNotInvoked" },
              { "option_id": "b", "text": "NullPointerException" },
              { "option_id": "c", "text": "UnverifiedStubException" },
              { "option_id": "d", "text": "IllegalMockException" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q8",
            "question_text": "Що робить `@Mock` в Mockito?",
            "options": [
              { "option_id": "a", "text": "Створює і ініціалізує мок-об’єкт" },
              { "option_id": "b", "text": "Інжектить залежність" },
              { "option_id": "c", "text": "Позначає метод як тестовий" },
              { "option_id": "d", "text": "Створює новий екземпляр тестового класу" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q9",
            "question_text": "Як змусити мок кидати виняток у Mockito?",
            "options": [
              { "option_id": "a", "text": "when(mock.method()).thenThrow(new RuntimeException())" },
              { "option_id": "b", "text": "mock.method().throw(new RuntimeException())" },
              { "option_id": "c", "text": "given(mock).willThrow(Exception.class)" },
              { "option_id": "d", "text": "mock.throw(RuntimeException.class)" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q10",
            "question_text": "Яка з анотацій використовується для інжекції моків у тестований об’єкт?",
            "options": [
              { "option_id": "a", "text": "@InjectMocks" },
              { "option_id": "b", "text": "@Autowired" },
              { "option_id": "c", "text": "@Spy" },
              { "option_id": "d", "text": "@RunWith" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q11",
            "question_text": "Що таке spy у Mockito?",
            "options": [
              { "option_id": "a", "text": "Обгортка навколо реального об’єкта, яка дозволяє його частково мокати" },
              { "option_id": "b", "text": "Повністю підроблений об’єкт" },
              { "option_id": "c", "text": "Статичний мок" },
              { "option_id": "d", "text": "Фабрика моків" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q12",
            "question_text": "Як вказати, що тест має завершитися з винятком у JUnit 5?",
            "options": [
              { "option_id": "a", "text": "assertThrows(Exception.class, () -> ...);" },
              { "option_id": "b", "text": "@Expect(Exception.class)" },
              { "option_id": "c", "text": "@Throws(RuntimeException.class)" },
              { "option_id": "d", "text": "@ExceptionTest" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q13",
            "question_text": "Як в Mockito перевірити, що метод викликано лише один раз?",
            "options": [
              { "option_id": "a", "text": "verify(mock, times(1)).method();" },
              { "option_id": "b", "text": "assertEquals(1, mock.calls())" },
              { "option_id": "c", "text": "verifyOnce(mock).method();" },
              { "option_id": "d", "text": "mock.verifyCount(1).method();" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q14",
            "question_text": "Що таке `ArgumentCaptor` в Mockito?",
            "options": [
              { "option_id": "a", "text": "Інструмент для перехоплення аргументів під час виклику методу" },
              { "option_id": "b", "text": "Інструмент логування" },
              { "option_id": "c", "text": "Механізм створення моків" },
              { "option_id": "d", "text": "Об’єкт конфігурації моків" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q15",
            "question_text": "Як протестувати приватний метод напряму (без рефлексії)?",
            "options": [
              { "option_id": "a", "text": "Неможливо — протестувати через публічний інтерфейс" },
              { "option_id": "b", "text": "Використати @PrivateTest" },
              { "option_id": "c", "text": "Mockito робить це автоматично" },
              { "option_id": "d", "text": "JUnit підтримує @ExposePrivate" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q16",
            "question_text": "Що повертає `when(...).thenReturn(...)` у Mockito?",
            "options": [
              { "option_id": "a", "text": "Оригінальне значення або мок" },
              { "option_id": "b", "text": "Масив відповідей" },
              { "option_id": "c", "text": "Ітератор" },
              { "option_id": "d", "text": "Команда виконання" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q17",
            "question_text": "Як протестувати метод, що викликає сторонній сервіс (наприклад, HTTP API)?",
            "options": [
              { "option_id": "a", "text": "Замінити залежність на мок і задати результат" },
              { "option_id": "b", "text": "Додати затримку в тесті" },
              { "option_id": "c", "text": "Використати try-catch" },
              { "option_id": "d", "text": "Інтегрувати прямо в реальний сервіс" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q18",
            "question_text": "Який тип тестів фокусуються на одному класі і ізольовують всі зовнішні залежності?",
            "options": [
              { "option_id": "a", "text": "Юніт-тести" },
              { "option_id": "b", "text": "Інтеграційні тести" },
              { "option_id": "c", "text": "Системні тести" },
              { "option_id": "d", "text": "Ручне тестування" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q19",
            "question_text": "Що робить `@Spy` в Mockito?",
            "options": [
              { "option_id": "a", "text": "Дозволяє стежити за реальним об’єктом і мокати його частково" },
              { "option_id": "b", "text": "Повністю замінює об'єкт на мок" },
              { "option_id": "c", "text": "Інжектить залежність у мок" },
              { "option_id": "d", "text": "Використовується для реєстрації хука" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q20",
            "question_text": "Що буде, якщо не викликати `MockitoAnnotations.openMocks(this)` у класі з `@Mock`?",
            "options": [
              { "option_id": "a", "text": "Поля не будуть ініціалізовані, і буде NullPointerException" },
              { "option_id": "b", "text": "Моки будуть створені автоматично" },
              { "option_id": "c", "text": "JUnit видасть попередження" },
              { "option_id": "d", "text": "Моки працюватимуть частково" }
            ],
            "correct_option_id": "a"
          }
        ]
      }
    ]
  }
}
