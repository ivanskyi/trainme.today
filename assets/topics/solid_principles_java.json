{
  "topic": {
    "id": "solid_principles_java",
    "name": "SOLID Принципи",
    "description": "20 технічних запитань з SOLID для Java-розробників",
    "tests": [
      {
        "test_id": "solid_test_ua",
        "test_title": "Тест на знання SOLID принципів",
        "questions": [
          {
            "question_id": "q1",
            "question_text": "Що означає принцип Single Responsibility (SRP)?",
            "options": [
              { "option_id": "a", "text": "Клас повинен мати лише одну відповідальність" },
              { "option_id": "b", "text": "Метод повинен викликатися лише один раз" },
              { "option_id": "c", "text": "Один розробник повинен писати один клас" },
              { "option_id": "d", "text": "Клас має містити лише одну змінну" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q2",
            "question_text": "Який з наступних прикладів порушує SRP?",
            "options": [
              { "option_id": "a", "text": "Клас, що обробляє логіку та пише у файл" },
              { "option_id": "b", "text": "Клас, який обчислює відсотки" },
              { "option_id": "c", "text": "Інтерфейс з одним методом" },
              { "option_id": "d", "text": "Клас, що наслідує від абстрактного класу" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q3",
            "question_text": "Принцип Open/Closed (OCP) означає:",
            "options": [
              { "option_id": "a", "text": "Клас відкритий для розширення, але закритий для модифікації" },
              { "option_id": "b", "text": "Клас закритий для розширення та модифікації" },
              { "option_id": "c", "text": "Клас можна редагувати лише через API" },
              { "option_id": "d", "text": "Клас повинен бути лише public" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q4",
            "question_text": "Що зазвичай використовують для дотримання OCP?",
            "options": [
              { "option_id": "a", "text": "Інтерфейси та абстрактні класи" },
              { "option_id": "b", "text": "Рефлексію" },
              { "option_id": "c", "text": "Статичні методи" },
              { "option_id": "d", "text": "Приватні поля" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q5",
            "question_text": "Liskov Substitution Principle (LSP) говорить:",
            "options": [
              { "option_id": "a", "text": "Підкласи повинні заміняти базові класи без порушення логіки" },
              { "option_id": "b", "text": "Підкласи не можуть перевизначати методи" },
              { "option_id": "c", "text": "Підкласи мають бути final" },
              { "option_id": "d", "text": "Базові класи не повинні мати реалізації" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q6",
            "question_text": "Яке з наведеного порушує LSP?",
            "options": [
              { "option_id": "a", "text": "Підклас викидає виняток у перевизначеному методі без необхідності" },
              { "option_id": "b", "text": "Підклас розширює функціонал базового класу" },
              { "option_id": "c", "text": "Підклас перевизначає метод equals()" },
              { "option_id": "d", "text": "Підклас додає новий метод" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q7",
            "question_text": "Інтерфейс Segregation Principle (ISP) вимагає:",
            "options": [
              { "option_id": "a", "text": "Краще створити декілька дрібних інтерфейсів, ніж один великий" },
              { "option_id": "b", "text": "Всі інтерфейси мають мати тільки один метод" },
              { "option_id": "c", "text": "Інтерфейси повинні бути public" },
              { "option_id": "d", "text": "Класи не мають реалізовувати інтерфейси" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q8",
            "question_text": "Яке з тверджень є порушенням ISP?",
            "options": [
              { "option_id": "a", "text": "Інтерфейс `Printer` має методи print(), scan(), fax()" },
              { "option_id": "b", "text": "Клас реалізує два окремих інтерфейси" },
              { "option_id": "c", "text": "Інтерфейс містить лише метод print()" },
              { "option_id": "d", "text": "Реалізація одного методу в класі" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q9",
            "question_text": "Принцип Dependency Inversion (DIP) означає:",
            "options": [
              { "option_id": "a", "text": "Модулі повинні залежати від абстракцій, а не реалізацій" },
              { "option_id": "b", "text": "Код має залежати лише від базових типів" },
              { "option_id": "c", "text": "Залежності повинні бути final" },
              { "option_id": "d", "text": "Абстракції мають наслідувати класи" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q10",
            "question_text": "Яке з тверджень реалізує DIP?",
            "options": [
              { "option_id": "a", "text": "Клас залежить від інтерфейсу, а не конкретної реалізації" },
              { "option_id": "b", "text": "Клас створює залежності через new" },
              { "option_id": "c", "text": "Клас використовує статичні виклики" },
              { "option_id": "d", "text": "Клас зберігає всі залежності як приватні поля" }
            ],
            "correct_option_id": "a"
          },

          {
            "question_id": "q11",
            "question_text": "Який принцип порушено, якщо клас виконує зчитування файлу і обчислення даних?",
            "options": [
              { "option_id": "a", "text": "SRP" },
              { "option_id": "b", "text": "OCP" },
              { "option_id": "c", "text": "LSP" },
              { "option_id": "d", "text": "ISP" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q12",
            "question_text": "Яке твердження найкраще ілюструє OCP?",
            "options": [
              { "option_id": "a", "text": "Можна додати нову поведінку, не змінюючи існуючий код" },
              { "option_id": "b", "text": "Можна змінити логіку методу через рефлексію" },
              { "option_id": "c", "text": "Методи повинні бути public" },
              { "option_id": "d", "text": "Всі поля мають бути доступні через get/set" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q13",
            "question_text": "Як краще реалізувати DIP в Java?",
            "options": [
              { "option_id": "a", "text": "Інжекція залежностей через інтерфейси" },
              { "option_id": "b", "text": "new в конструкторі" },
              { "option_id": "c", "text": "Використання статичних полів" },
              { "option_id": "d", "text": "Singleton-патерн" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q14",
            "question_text": "Що є перевагою дотримання принципу LSP?",
            "options": [
              { "option_id": "a", "text": "Можна використовувати підкласи без побічних ефектів" },
              { "option_id": "b", "text": "Зменшується кількість класів" },
              { "option_id": "c", "text": "Можна не писати тести" },
              { "option_id": "d", "text": "Можна використовувати статичні методи" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q15",
            "question_text": "Що з наведеного НЕ є перевагою SOLID?",
            "options": [
              { "option_id": "a", "text": "Більш складний код" },
              { "option_id": "b", "text": "Краща підтримуваність" },
              { "option_id": "c", "text": "Легкість у розширенні" },
              { "option_id": "d", "text": "Модульність" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q16",
            "question_text": "Що краще демонструє ISP?",
            "options": [
              { "option_id": "a", "text": "Інтерфейс Printable з одним методом print()" },
              { "option_id": "b", "text": "Інтерфейс Device з 5 методами: print(), scan(), fax(), copy(), email()" },
              { "option_id": "c", "text": "Інтерфейс з методами equals() та hashCode()" },
              { "option_id": "d", "text": "Інтерфейс Serializable" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q17",
            "question_text": "Чому слід уникати залежності від конкретного класу?",
            "options": [
              { "option_id": "a", "text": "Зменшується гнучкість і тестованість" },
              { "option_id": "b", "text": "Це уповільнює компіляцію" },
              { "option_id": "c", "text": "Код займає більше пам’яті" },
              { "option_id": "d", "text": "Це порушує інкапсуляцію" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q18",
            "question_text": "Який принцип безпосередньо пов’язаний із поліморфізмом?",
            "options": [
              { "option_id": "a", "text": "LSP" },
              { "option_id": "b", "text": "SRP" },
              { "option_id": "c", "text": "ISP" },
              { "option_id": "d", "text": "DIP" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q19",
            "question_text": "Що з наведеного краще відповідає принципу SRP?",
            "options": [
              { "option_id": "a", "text": "Клас UserService відповідає тільки за логіку користувача" },
              { "option_id": "b", "text": "Клас має логіку входу і логування" },
              { "option_id": "c", "text": "Клас має методи для API, бізнес-логіки та БД" },
              { "option_id": "d", "text": "Клас має багато приватних змінних" }
            ],
            "correct_option_id": "a"
          },
          {
            "question_id": "q20",
            "question_text": "Який принцип порушується, якщо клас створює свою залежність через `new`?",
            "options": [
              { "option_id": "a", "text": "DIP" },
              { "option_id": "b", "text": "LSP" },
              { "option_id": "c", "text": "SRP" },
              { "option_id": "d", "text": "OCP" }
            ],
            "correct_option_id": "a"
          }
        ]
      }
    ]
  }
}
